#include <frames.hpp>
#include <joint.hpp>
#include <frames_io.hpp>
#include <chainidsolver_constraint_vereshchagin.hpp>
#include <chainfksolverpos_recursive.hpp>
#include <chainidsolver_recursive_newton_euler.hpp>
#include <chain.hpp>
#include <kinfam_io.hpp>
#include <iostream>
#include <Eigen/SVD>
#include "utilities/svd_eigen_HH.hpp"

int main()
{

    using namespace KDL;


    //Definition of kinematic chain
    //-----------------------------------------------------------------------------------------------//
    //Joint (const JointType &type=None, const double &scale=1, const double &offset=0, const double &inertia=0, const double &damping=0, const double &stiffness=0)
    Joint rotJoint0 = Joint(Joint::RotZ, 1, 0, 0.01);
    Joint rotJoint1 = Joint(Joint::RotZ, 1, 0, 0.01);

    Frame refFrame(Rotation::RPY(0.0, 0.0, 0.0), Vector(0.0, 0.0, 0.0));
    Frame frame1(Rotation::RPY(0.0, 0.0, 0.0), Vector(0.0, -0.4, 0.0));
    Frame frame2(Rotation::RPY(0.0, 0.0, 0.0), Vector(0.0, -0.4, 0.0));
    //Segment (const Joint &joint=Joint(Joint::None), const Frame &f_tip=Frame::Identity(), const RigidBodyInertia &I=RigidBodyInertia::Zero())
    Segment segment1 = Segment(rotJoint0, frame1);
    Segment segment2 = Segment(rotJoint1, frame2);

    // 	RotationalInertia (double Ixx=0, double Iyy=0, double Izz=0, double Ixy=0, double Ixz=0, double Iyz=0)
    RotationalInertia rotInerSeg1(0.0, 0.0, 0.0, 0.0, 0.0, 0.0); //around symmetry axis of rotation
    //RigidBodyInertia (double m=0, const Vector &oc=Vector::Zero(), const RotationalInertia &Ic=RotationalInertia::Zero())
    RigidBodyInertia inerSegment1(0.3, Vector(0.0, -0.4, 0.0), rotInerSeg1);
    RigidBodyInertia inerSegment2(0.3, Vector(0.0, -0.4, 0.0), rotInerSeg1);
    segment1.setInertia(inerSegment1);
    segment2.setInertia(inerSegment2);

    Chain chain;
    chain.addSegment(segment1);
    chain.addSegment(segment2);
    //~Definition of kinematic chain
    //----------------------------------------------------------------------------------------------//



    //Definition of constraints and external disturbances
    //--------------------------------------------------------------------------------------//
    //Constraint force matrix at the end-effector
    //What is the convention for the spatial force matrix; is it the same as in thesis?
    //NOTE AZAMAT: Constraint are also defined in local reference frame?!
    Vector constrainXLinear(1.0, 0.0, 0.0);
    Vector constrainXAngular(0.0, 0.0, 0.0);
    Vector constrainYLinear(0.0, 0.0, 0.0);
    Vector constrainYAngular(0.0, 0.0, 0.0);
    Vector constrainZLinear(0.0, 0.0, 0.0);
    Vector constrainZAngular(0.0, 0.0, 0.0);
    Twist constraintForcesX(constrainXLinear, constrainXAngular);
    Twist constraintForcesY(constrainYLinear, constrainYAngular);
    Twist constraintForcesZ(constrainZLinear, constrainZAngular);
    Jacobian alpha(2);
    alpha.setColumn(0, constraintForcesX);
    alpha.setColumn(1, constraintForcesY);


    //Acceleration energy at  the end-effector
    JntArray betha(2); //set to zero
    betha(0) = 0.0;
    betha(1) = 0.0;
    //betha(2) = 0.0;

    //arm root acceleration
    Vector linearAcc(0.0, 9.8, 0.0); //gravitational acceleration along Y
    Vector angularAcc(0.0, 0.0, 0.0);
    Twist twist1(linearAcc, angularAcc);

    //external forces on the arm
    Vector externalForce1(0.0, 0.0, 0.0);
    Vector externalTorque1(0.0, 0.0, 0.0);
    Vector externalForce2(0.0, 0.0, 0.0);
    Vector externalTorque2(0.0, 0.0, 0.0);
    Wrench externalNetForce1(externalForce1, externalTorque1);
    Wrench externalNetForce2(externalForce2, externalTorque2);
    Wrenches externalNetForce;
    externalNetForce.push_back(externalNetForce1);
    externalNetForce.push_back(externalNetForce2);
    //~Definition of constraints and external disturbances
    //-------------------------------------------------------------------------------------//


    //Definition of solver and initial configuration
    //-------------------------------------------------------------------------------------//
    ChainFkSolverPos_recursive fksolver(chain);
    //ChainFkSolverVel_recursive fksolverVel(chain);
    int numberOfConstraints = 2;
    ChainIdSolver_Constraint_Vereshchagin constraintSolver(chain, twist1, numberOfConstraints);



    //These arrays of joint values contain actual and desired values
    //actual is generated by a solver and integrator
    //desired is given by an interpolator
    //error is the difference between desired-actual
    int k = 3;
    JntArray jointPoses[k];
    JntArray jointRates[k];
    JntArray jointAccelerations[k];
    JntArray jointTorques[k];
    JntArray biasqDotDot(chain.getNrOfJoints());
    for (int i = 0; i < k; i++)
    {
        JntArray jointValues(chain.getNrOfJoints());
        jointPoses[i] = jointValues;
        jointRates[i] = jointValues;
        jointAccelerations[i] = jointValues;
        jointTorques[i] = jointValues;
    }


    // Initial arm position configuration/constraint
    JntArray jointInitialPose(chain.getNrOfJoints());
    jointInitialPose(0) = 0.0; // initial joint0 pose
    jointInitialPose(1) = M_PI / 6.0; //initial joint1 pose, negative in clockwise
    //these correspond to x = 0.2, y = -0.7464
    //actual
    jointPoses[0](0) = jointInitialPose(0);
    jointPoses[0](1) = jointInitialPose(1);
    //desired
    jointPoses[1](0) = jointInitialPose(0);
    jointPoses[1](1) = jointInitialPose(1);

    //final arm position constraint
    Frame frameFinalPose(Vector(0.6, 0.0, 0)); //final postion of the end effector in Cartesian space //corresponds to q(0) = 25.842 and q(1) = 128.416
    JntArray qFinalPose(chain.getNrOfJoints()); //final positions of joints in joint space, joint values basically
    qFinalPose(0) = M_PI * 48.59 / 180.0;
    qFinalPose(1) = M_PI * 97.18 / 180.0;

    printf("joint initial and final values: %f         %f          %f      %f\n", jointInitialPose(0), jointInitialPose(1), qFinalPose(0), qFinalPose(1));

    //cartesian space/link values
    Frames cartX;
    cartX.push_back(frame1);
    cartX.push_back(frame2);

    Twist accLink0;
    Twist accLink1;
    Twists cartXDotDot;
    cartXDotDot.push_back(accLink0);
    cartXDotDot.push_back(accLink1);

    Twists cartXDot;
    cartXDot.push_back(accLink0);
    cartXDot.push_back(accLink1);

    Frames tempCartX(cartX);
    Twists tempCartXDot(cartXDot);
    Twists tempCartXDotDot(cartXDotDot);


    //~Definition of solver and initial configuration
    //-------------------------------------------------------------------------------------//

    //Chain Jacobian and its right pseudo inverse
    //J = [-a1s1-a2s2    -a2s12, a1c1+a2c12  a2c12 , 0 0, 0 0, 0 0, 1 1]
    //J_peusdoInv = JTranspose(J*JTranspose)^-1
    /*
    
          Vector jacobianColumnX1(j1, j3, 0.0);
          Vector jacobianColumnX2(j2, j4, 0.0);
          Vector jacobianColumnY1(0.0, 0.0, 1.0);
          Vector jacobianColumnY2(0.0, 0.0, 1.0);
          Twist chainJacobianColumn1(jacobianColumnX1, jacobianColumnY1);
          Twist chainJacobianColumn2(jacobianColumnX2, jacobianColumnY2);
     */
    double j1 = 0;
    double j2 = 0;
    double j3 = 0;
    double j4 = 0;

    Eigen::MatrixXd chainJacobian(6, 2);
    Eigen::MatrixXd chainJacobianInverse;
    Eigen::MatrixXd U;
    Eigen::MatrixXd V;
    Eigen::VectorXd Sigma;
    Eigen::VectorXd tempSigma;


    chainJacobian.setZero();
    chainJacobian(5, 0) = 1;
    chainJacobian(5, 1) = 1;
    Eigen::SVD<MatrixXd> svdChainJacobian(chainJacobian);








    //Definition of process main loop
    //-------------------------------------------------------------------------------------//
    double TimeConstant = 10; //Time required to complete the task move(frameinitialPose, framefinalPose) default T=10.0
    double timeDelta = 0.001;
    bool status;


    //Interpolator parameters:
    double b0_y = -0.7464 ; //should come from initial joint configuration
    double b1_y = 0.0;
    double b2_y = ((0.5 + 0.7464)*3.0/TimeConstant*TimeConstant);
    double b3_y = -((0.5 + 0.7464)*2.0/TimeConstant*TimeConstant*TimeConstant);

    /*
    double a0_q0 = jointPoses[1](0);
    double a1_q0 = 0.0;
    double a2_q0 = ((qFinalPose(0) - jointPoses[1](0))*3.0 / TimeConstant * TimeConstant);
    double a3_q0 = -((qFinalPose(0) - jointPoses[1](0))*2.0 / TimeConstant * TimeConstant * TimeConstant);

    double a0_q1 = jointPoses[1](1);
    double a1_q1 = 0.0;
    double a2_q1 = ((qFinalPose(1) - jointPoses[1](1))*3.0 / TimeConstant * TimeConstant);
    double a3_q1 = -((qFinalPose(1) - jointPoses[1](1))*2.0 / TimeConstant * TimeConstant * TimeConstant);

     */

  
    double Kp = 10.0;
    double Kv = 10.0;

    for (double t = 0.0; t <= TimeConstant; t = t + timeDelta)
    {


        // Jacobian inverse
        j1 = -0.4 * sin(jointPoses[0](0)) - 0.4 * sin(jointPoses[0](1));
        j2 = -0.4 * sin(jointPoses[0](0) + jointPoses[0](0));
        j3 = 0.4 * cos(jointPoses[0](0)) + 0.4 * cos(jointPoses[0](0) + jointPoses[0](1));
        j4 = 0.4 * cos(jointPoses[0](0) + jointPoses[0](1));

        //printf("t, j1, j2, j3, j4   %f      %f          %f      %f      %f\n", t, j1, j2, j3, j4);

        chainJacobian(0, 0) = j1;
        chainJacobian(0, 1) = j2;
        chainJacobian(1, 0) = j3;
        chainJacobian(1, 1) = j4;

        std::cout << "This is jacobian" << std::endl << chainJacobian << std::endl;

        svdChainJacobian.compute(chainJacobian);
        U = svdChainJacobian.matrixU();
        V = svdChainJacobian.matrixV();
        Sigma = svdChainJacobian.singularValues();
        tempSigma = Sigma.cwise().inverse();
        U = U.transpose().eval();
        chainJacobianInverse = V * tempSigma.asDiagonal();
        chainJacobianInverse = chainJacobianInverse*U;

        std::cout << "This is jacobian inverse" << std::endl << chainJacobianInverse << std::endl;

        tempCartX[1].p[0] = 0.0;
        tempCartX[1].p[1] = b0_y + b1_y*t + b2_y*t*t +b3_y*t*t*t ;
        tempCartXDot[1].vel[0] = 0.0;
        tempCartXDot[1].vel[1] = b1_y + 2*b2_y*t + 3*b3_y*t*t ;
        tempCartXDotDot[1].vel[0] = 0.0;
        tempCartXDotDot[1].vel[1] = 2*b2_y + 6*b3_y*t ;
        printf("Desired Cartesian values:  %f          %f      %f     %f         %f        %f      %f\n", t, tempCartX[1].p[0], tempCartX[1].p[1], tempCartXDot[1].vel[0], tempCartXDot[1].vel[1], tempCartXDotDot[1].vel[0], tempCartXDotDot[1].vel[1]);


        //NOTE AZAMAT:what is qTorque? in implementation returned qTorque is constraint torque generated by the virtual constraint forces.
        // these torques are required to satify a virtual constraint and basically are real torques applied to joints to achieve
        // these constraint. But if additionally to the constraint generated torques we also had internal motor torques, then should not they
        //be added together?
        //qTorque(0) = qTorque(0) + feedforwardJointTorque0;
        //qTorque(1) = qTorque(1) + feedforwardJointTorque1;
        // In what frame of reference are the results expressed? Also local?!





        //Interpolation (Desired) q = a0+a1t+a2t^2+a3t^3
        //Do we feed these values? then         jointPoses[0] = jointPoses[1];         jointRates[0] = jointRates[1];
        // But I don't think so, in control desired trajectory plays role of the reference that the controller should strive for from its actual (previous, current) state.
        /*
        jointPoses[1](0) = a0_q0 + a1_q0 * t + a2_q0 * t * t + a3_q0 * t * t*t;
        jointPoses[1](1) = a0_q1 + a1_q1 * t + a2_q1 * t * t + a3_q1 * t * t*t;
        jointRates[1](0) = a1_q0 + 2 * a2_q0 * t + 3 * a3_q0 * t*t;
        jointRates[1](1) = a1_q1 + 2 * a2_q1 * t + 3 * a3_q1 * t*t;
        jointAccelerations[1](0) = 2 * a2_q0 + 6 * a3_q0*t;
        jointAccelerations[1](1) = 2 * a2_q1 + 6 * a3_q1*t;
        printf("Desired joint values: %f         %f          %f      %f       %f     %f       %f\n", t, jointPoses[1](0), jointPoses[1](1), jointRates[1](0), jointRates[1](1), jointAccelerations[1](0), jointAccelerations[1](1));

        tempCartX[1].p[0] = 0.4; //b0_x + b1_x*t + b2_x*t*t +b3_x*t*t*t ;
        tempCartX[1].p[1] = 0.0;
        tempCartXDot[1].vel[0] = 0.0; //b1_x + 2*b2_x*t + 3*b3_x*t*t ;
        tempCartXDot[1].vel[1] = 0.0;
        tempCartXDotDot[1].vel[0] = 0.0; //2*b2_x + 6*b3_x*t ;
        tempCartXDotDot[1].vel[1] = 0.0;
        printf("Desired joint values: %f         %f          %f      %f       %f     %f       %f\n", t, jointPoses[1](0), jointPoses[1](1), jointRates[1](0), jointRates[1](1), jointAccelerations[1](0), jointAccelerations[1](1));
        printf("Desired Cartesian values:  %f          %f      %f     %f         %f        %f      %f\n", t, tempCartX[1].p.x(), tempCartX[1].p.y(), tempCartXDot[1].vel.x(), tempCartXDot[1].vel.y(), tempCartXDotDot[1].vel.x(), tempCartXDotDot[1].vel.y());
         */
        status = constraintSolver.CartToJnt(jointPoses[0], jointRates[0], jointAccelerations[0], cartXDotDot, alpha, betha, externalNetForce, jointTorques[0]);
        constraintSolver.getLinkCartesianPose(cartX);
        constraintSolver.getLinkCartesianVelocity(cartXDot);
        constraintSolver.getJointBiasAcceleration(biasqDotDot);
        if (status >= 0)
        {

            //For 2-dof arm
            /*
            printf("%f          %f      %f       %f     %f       %f     %f           %f     %f           %f     %f\n",t , arrayOfJoints(0), arrayOfJoints(1), qDot(0), qDot(1), qDotDot(0), qDotDot(1), qTorque(0), qTorque(1), biasqDotDot(0), biasqDotDot(1));
            printf("%f          %f      %f     %f         %f        %f      %f\n", t, cartXDot[1].vel.x(), cartXDot[1].vel.y(), cartXDot[1].rot.z(), cartXDotDot[1].vel.x(), cartXDotDot[1].vel.y(), cartXDotDot[1].rot.z());
            printf("Actual Cartesian values:  %f          %f      %f     %f         %f        %f      %f\n", t, cartX[1].p.x(),cartX[1].p.y(), cartXDot[1].vel.x(), cartXDot[1].vel.y(), cartXDotDot[1].vel.x(), cartXDotDot[1].vel.y());
            printf("Actual joint values:  %f          %f      %f       %f     %f       %f     %f           %f     %f\n", t, jointPoses[0](0), jointPoses[0](1), jointRates[0](0), jointRates[0](1), jointAccelerations[0](0), jointAccelerations[0](1), jointTorques[0](0), jointTorques[0](1));
             */
            //printf("Actual Cartesian values:  %f          %f      %f     %f         %f        %f      %f\n", t, cartX[1].p.x(),cartX[1].p.y(), cartXDot[1].vel.x(), cartXDot[1].vel.y(), cartXDotDot[1].vel.x(), cartXDotDot[1].vel.y());


        }

        /*

                betha(0) = betha(0) -
                           (alpha.getColumn(0).vel.x()*(cartXDotDot[1].vel.x() - tempCartXDotDot[1].vel.x())
                            +alpha.getColumn(0).vel.y()*(cartXDotDot[1].vel.y() - tempCartXDotDot[1].vel.y())
                            +alpha.getColumn(0).vel.z()*(cartXDotDot[1].vel.z() - tempCartXDotDot[1].vel.z())
                            +alpha.getColumn(0).rot.x()*(cartXDotDot[1].rot.x() - tempCartXDotDot[1].rot.x())
                            +alpha.getColumn(0).rot.y()*(cartXDotDot[1].rot.y() - tempCartXDotDot[1].rot.y())
                            +alpha.getColumn(0).rot.z()*(cartXDotDot[1].rot.x() - tempCartXDotDot[1].rot.z()))

                            -(2*alpa*(alpha.getColumn(0).vel.x()*(cartXDot[1].vel.x() - tempCartXDot[1].vel.x())
                            +alpha.getColumn(0).vel.y()*(cartXDot[1].vel.y() - tempCartXDot[1].vel.y())
                            +alpha.getColumn(0).vel.z()*(cartXDot[1].vel.z() - tempCartXDot[1].vel.z())
                            +alpha.getColumn(0).rot.x()*(cartXDot[1].rot.x() - tempCartXDot[1].rot.x())
                            +alpha.getColumn(0).rot.y()*(cartXDot[1].rot.y() - tempCartXDot[1].rot.y())
                            +alpha.getColumn(0).rot.z()*(cartXDot[1].rot.z() - tempCartXDot[1].rot.z()))
                            +beta*beta*(cartX[1].p.x() - tempCartX[1].p.x()));


                betha(1) = betha(1) -
                            (alpha.getColumn(1).vel.x()*(cartXDotDot[1].vel.x() - tempCartXDotDot[1].vel.x())
                            +alpha.getColumn(1).vel.y()*(cartXDotDot[1].vel.y() - tempCartXDotDot[1].vel.y())
                            +alpha.getColumn(1).vel.z()*(cartXDotDot[1].vel.z() - tempCartXDotDot[1].vel.z())
                            +alpha.getColumn(1).rot.x()*(cartXDotDot[1].rot.x() - tempCartXDotDot[1].rot.x())
                            +alpha.getColumn(1).rot.y()*(cartXDotDot[1].rot.y() - tempCartXDotDot[1].rot.y())
                            +alpha.getColumn(1).rot.z()*(cartXDotDot[1].rot.z() - tempCartXDotDot[1].rot.z()))

                            -
                            (2*alpa*(alpha.getColumn(1).vel.x()*(cartXDot[1].vel.x() - tempCartXDot[1].vel.x())
                            +alpha.getColumn(1).vel.y()*(cartXDot[1].vel.y() - tempCartXDot[1].vel.y())
                            +alpha.getColumn(1).vel.z()*(cartXDot[1].vel.z() - tempCartXDot[1].vel.z())
                            +alpha.getColumn(1).rot.x()*(cartXDotDot[1].rot.x() - tempCartXDotDot[1].rot.x())
                            +alpha.getColumn(1).rot.y()*(cartXDotDot[1].rot.y() - tempCartXDotDot[1].rot.y())
                            +alpha.getColumn(1).rot.z()*(cartXDotDot[1].rot.z() - tempCartXDotDot[1].rot.z()))
                            +beta*beta*(cartX[1].p.y() - tempCartX[1].p.y()));

         *                  qDotDot(1) = (cartXDotDot[1].rot.z()-biasqDotDot(0)) + Kv*(tempCartXDot[1].rot.z() - cartXDot[1].rot.z()) + Kp*(tempCartX[1].p.x() - cartX[1].p.x());
                            qDotDot(0) = (cartXDotDot[0].rot.z()-biasqDotDot(0)) + Kv*(tempCartXDot[0].rot.z() - cartXDot[0].rot.z()) + Kp*(tempCartX[0].p.x() - cartX[0].p.x());

         *
         *
         */
        printf("Actual joint values:  %f          %f      %f       %f     %f       %f      %f\n", t, jointPoses[0](0), jointPoses[0](1), jointRates[0](0), jointRates[0](1), jointAccelerations[0](0), jointAccelerations[0](1));
        printf("Actual Cartesian values:  %f          %f      %f     %f         %f        %f      %f\n", t, cartX[1].p.x(),cartX[1].p.y(), cartXDot[1].vel.x(), cartXDot[1].vel.y(), cartXDotDot[1].vel.x(), cartXDotDot[1].vel.y());

        //Regulator or controller

        //need Jacobian pseudo-inverse
        jointAccelerations[0](0) = chainJacobianInverse(0, 0)*((tempCartXDotDot[1].vel.x() - biasqDotDot(0)) + Kv * (tempCartX[1].p.x() - cartX[1].p.x()) + Kp * (tempCartXDot[1].vel.x() - cartXDot[1].vel.x()))
                + chainJacobianInverse(0, 1)*((tempCartXDotDot[1].vel.y() - biasqDotDot(1)) + Kv * (tempCartX[1].p.y() - cartX[1].p.y()) + Kp * (tempCartXDot[1].vel.y() - cartXDot[1].vel.y()));
        jointAccelerations[0](1) = chainJacobianInverse(1, 0)*((tempCartXDotDot[1].vel.x() - biasqDotDot(0)) + Kv * (tempCartX[1].p.x() - cartX[1].p.x()) + Kp * (tempCartXDot[1].vel.x() - cartXDot[1].vel.x()))
                + chainJacobianInverse(1, 1)*((tempCartXDotDot[1].vel.y() - biasqDotDot(1)) + Kv * (tempCartX[1].p.y() - cartX[1].p.y()) + Kp * (tempCartXDot[1].vel.y() - cartXDot[1].vel.y()));
        printf("Corrected joint accelerations values:  %f          %f      %f\n", t, jointAccelerations[0](0), jointAccelerations[0](1));
        //Integration at the given "instanteneous" interval for joint position and velocity.
        //These will be inputs for the next time instant
        //actually here it should be a time interval and not time from the beginning, that is why timeDelta;

        //Integration (actual)
        jointRates[0](0) = jointRates[0](0) + jointAccelerations[0](0) * timeDelta; //Euler Forward
        jointPoses[0](0) = jointPoses[0](0) + (jointRates[0](0) - jointAccelerations[0](0) * timeDelta / 2.0) * timeDelta; //Trapezoidal rule
        jointRates[0](1) = jointRates[0](1) + jointAccelerations[0](1) * timeDelta; //Euler Forward
        jointPoses[0](1) = jointPoses[0](1) + (jointRates[0](1) - jointAccelerations[0](1) * timeDelta / 2.0) * timeDelta;

        printf("Corrected joint values:  %f          %f      %f       %f     %f  \n", t, jointPoses[0](0), jointPoses[0](1), jointRates[0](0), jointRates[0](1));

        /*
                //Error
                jointPoses[2](0) = jointPoses[1](0) - jointPoses[0](0);
                jointPoses[2](1) = jointPoses[1](1) - jointPoses[0](1);
                jointRates[2](0) = jointRates[1](0) - jointRates[0](0);
                jointRates[2](1) = jointRates[1](1) - jointRates[0](1);
                jointAccelerations[2](0) = jointAccelerations[1](0) - jointAccelerations[0](0);
                jointAccelerations[2](1) = jointAccelerations[1](1) - jointAccelerations[0](1);
                //   printf("Errors: %f          %f      %f          %f     %f       %f      %f\n", t, jointPoses[2](0), jointPoses[2](1), jointRates[2](0), jointRates[2](1), jointAccelerations[2](0), jointAccelerations[2](1));
         */
        /*
        feedforwardJointTorque0 = 20.0*jointPoses[2](0) + 2*jointRates[2](0);
        feedforwardJointTorque1 = 10.0*jointPoses[2](1) + 2*jointRates[2](1);
        printf("New feedforward torques:                                              %f      %f\n", feedforwardJointTorque0, feedforwardJointTorque1);

        jointTorques[0](0) = jointTorques[0](0) - feedforwardJointTorque0;
        jointTorques[0](1) = jointTorques[0](1) - feedforwardJointTorque1;
        printf("New torques2:                                                          %f      %f\n", jointTorques[0](0) , jointTorques[0](1));
         */
        //For cartesian space control one needs to calculate from the obtained joint space value, new cartesian space poses.
        //Then based on the difference of the signal (desired-actual) we define a regulation function (controller)
        // this difference should be compensated either by joint torques.

    }
    //~Definition of process main loop
    //-------------------------------------------------------------------------------------//





    return 0;
}
