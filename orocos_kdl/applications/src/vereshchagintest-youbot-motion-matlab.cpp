#include <frames.hpp>
#include <joint.hpp>
#include <frames_io.hpp>
#include <chainidsolver_vereshchagin.hpp>
#include <chainfksolverpos_recursive.hpp>
#include <chain.hpp>
#include <kinfam_io.hpp>
#include <iostream>
#include <kdl_parser/kdl_parser.hpp>
#include <urdf/model.h>

int main()
{

    using namespace KDL;
    
    KDL::Tree youBotTree;
    
    std::vector<KDL::Joint> joints;
    //note that it seems youbot_arm.urdf and youbot.urdf use different values.
    //parser's assumption is that it return joints which are not of type None.
   if (!kdl_parser::treeFromFile("/home/azamat/programming/ros-diamondback/youbot-ros-pkg/youbot_common/youbot_description/robots/youbot.urdf", youBotTree))
   {
      std::cout << "Failed to construct kdl tree" << std::endl;
      return false;
   }
 
   // else
   // {
       
   //     std::cout << "succeeded " << youBotTree.getNrOfJoints()<< std::endl;
   //     std::cout << "succeeded " << youBotTree.getNrOfSegments()<< std::endl;
       
   //     for(SegmentMap::const_iterator it = youBotTree.getSegments().begin(); it != youBotTree.getSegments().end(); it++ )
   //     {
   //         joints.push_back(it->second.segment.getJoint());
   //         std::cout << it->second.segment.getJoint().getName() << std::endl;
   //         std::cout << it->second.segment.getJoint().getTypeName() << std::endl;
   //         std::cout << it->first << std::endl;
   //     }
   // }
 
    KDL::Chain chain;
    youBotTree.getChain("arm_link_0","arm_link_5",chain);

    //These arrays of joint values contain actual and desired values
    //actual is generated by a solver and integrator
    //desired is given by an interpolator
    //error is the difference between desired-actual
    //0-actual, 1-desired, 2-error, 3-sum of error

    unsigned int k = 4;
    unsigned int numberOfJoints = chain.getNrOfJoints();
    // std::cout << "number of chain joints " << numberOfJoints << std::endl;
    JntArray jointPoses[k];
    JntArray jointRates[k];
    JntArray jointAccelerations[k];
    JntArray jointTorques[k];
    for (unsigned int i = 0; i < k; i++)
    {
        JntArray jointValues(numberOfJoints);
        jointPoses[i] = jointValues;
        jointRates[i] = jointValues;
        jointAccelerations[i] = jointValues;
        jointTorques[i] = jointValues;
    }

    //cartesian space/link values
    //0-actual, 1-desire, 2-error, 3-errorsum
    unsigned int numberOfLinks = chain.getNrOfSegments();
    // std::cout << "number of chain links " << numberOfLinks << std::endl;
    Frames cartX[k];
    Twists cartXDot[k];
    Twists cartXDotDot[k];
    Twist accLink;
    KDL::Frame frame1;
    for (unsigned int i = 0; i < k; i++) //i is number of variables (actual, desired, error)
    {
        for (unsigned int j = 0; j < numberOfLinks; j++) //j is number of links
        {
            cartX[i].push_back(frame1);
            cartXDot[i].push_back(accLink);
            cartXDotDot[i].push_back(accLink);
        }

    }

    //external forces on the arm
    Wrench externalNetForce;
    Wrenches externalNetForces;
    for (unsigned int i = 0; i < numberOfLinks; i++)
    {
        externalNetForces.push_back(externalNetForce);
    }

    // Initial arm position configuration/constraint, negative in clockwise
    JntArray jointInitialPose(numberOfJoints);
    jointInitialPose(0) = -M_PI/4.0;
    jointInitialPose(1) = M_PI / 6.0;
    jointInitialPose(2) = M_PI / 12.0;
    jointInitialPose(3) = -M_PI / 3.0;
    jointInitialPose(4) = M_PI / 18.0;
    //corresponds to x=0.031827      y = -0.007827     z = 0.472972
    JntArray jointFinalPose(numberOfJoints);
    jointFinalPose(0) = M_PI / 2.0;
    jointFinalPose(1) = M_PI / 2.5;
    jointFinalPose(2) = 0.0;
    jointFinalPose(3) = 0.0;
    jointFinalPose(4) = 0.0;
    // corresponds to 0.024000      -0.367062     0.242885 

    for (unsigned int i = 0; i < numberOfJoints; i++)
    {
        //actual initial
        jointPoses[0](i) = jointInitialPose(i);
        //desired initial
        jointPoses[1](i) = jointInitialPose(i);
    }

    //Definition of constraints and external disturbances
    //--------------------------------------------------------------------------------------//
    //Constraint force matrix at the end-effector
    //What is the convention for the spatial force matrix; is it the same as in thesis?
    //NOTE AZAMAT: Constraint are also defined in local reference frame?!
    unsigned int numberOfConstraints = 1;
    Twist constraintForce;
    Twists constraintForces;
    for (unsigned int i = 0; i < numberOfJoints; i++)
    {   
        SetToZero(constraintForce);
        constraintForces.push_back(constraintForce);
    }

    constraintForces[0].vel[0] = 1;

    //Acceleration energy and constraint matrix at  the end-effector
    Jacobian alpha(numberOfConstraints);
    JntArray betha(numberOfConstraints); //set to zero
    for (unsigned int i = 0; i < numberOfConstraints; i++)
    {
        alpha.setColumn(i, constraintForces[i]);
        betha(i) = 0.0;

    }
    //arm root acceleration
    Vector linearAcc(0.0, 0.0, 9.8); //gravitational acceleration along Z
    Vector angularAcc(0.0, 0.0, 0.0);
    Twist twist0(linearAcc, angularAcc);

    //test
    // ChainFkSolverPos_recursive fksolver(chain);
    // Frame tempEE;
    // fksolver.JntToCart(jointPoses[0], tempEE, 5);
    // std::cout << tempEE << std::endl;

    ChainIdSolver_Vereshchagin constraintSolver(chain, twist0, numberOfConstraints);
    //~Definition of solver and initial configuration

    //-------------------------------------------------------------------------------------//
    //Definition of process main loop
    //-------------------------------------------------------------------------------------//
    double taskTimeConstant = 2; //Time required to complete the task move(frameinitialPose, framefinalPose) default T=10.0
    double simulationTime = 2.5 * taskTimeConstant;
    double timeDelta = 0.001;
    double timeToSettle = 0.5;

    int status;
    double roll,pitch,yaw;
    //Controller gain configurations
    
    double ksi[3] = {1.0, 1.0, 1.0}; //damping factor
    double Kp[3];
    Kp[0] = 0.1475/(timeToSettle*timeToSettle);//0.1475
    Kp[1] = 1.0/(timeToSettle*timeToSettle);
    Kp[2] = 1.0/(timeToSettle*timeToSettle);
    double Kv[3];
    Kv[0] = 2.2245*ksi[0]/timeToSettle;//2.2245
    Kv[1] = 1.6*ksi[1]/timeToSettle;
    Kv[2] = 1.6*ksi[1]/timeToSettle;
    double Ki[3] = {0.0, 0.0, 0.0};
    double K = 0.005;
    
    /*
    //For cartesian space control with constraints and using external forces
    double ksi[2] = {1.0, 1.0}; //damping factor
    double Kp[2];
    Kp[0] = 6000.0/(taskTimeConstant*taskTimeConstant);
    Kp[1] = 11000.0/(taskTimeConstant*taskTimeConstant);
    double Kv[2];
    Kv[0] = 130*ksi[0]/taskTimeConstant;
    Kv[1] = 160*ksi[1]/taskTimeConstant;
    double Ki[2] = {-5.01, -5.1};

    //For cartesian space control without constraints using external forces
    double ksi[2] = {1.0, 1.0}; //damping factor
    double Kp[2];
    Kp[0] = 7000.0/(taskTimeConstant*taskTimeConstant);
    Kp[1] = 12000.0/(taskTimeConstant*taskTimeConstant);
    double Kv[2];
    Kv[0] = 130*ksi[0]/taskTimeConstant;
    Kv[1] = 160*ksi[1]/taskTimeConstant;
    double Ki[2] = {-5.01, -5.1};

    //For joint space control without constraints using computed torque
    double ksi[2] = {1.0, 1.0}; //damping factor
    double Kp[2];
    Kp[0] = 4000.0/(taskTimeConstant*taskTimeConstant);
    Kp[1] = 3200.0/(taskTimeConstant*taskTimeConstant);
    double Kv[2];
    Kv[0] = 20*ksi[0]/taskTimeConstant;
    Kv[1] = 30*ksi[1]/taskTimeConstant;
    double Ki[2] = {33.5, 10.5};
    double Ka[2] = {0.0, 0.0};
     
    
    //For joint space control without constraints using computed torque
    double ksi[2] = {1.0, 1.0}; //damping factor
    double Kp[2];
    Kp[0] = 4000.0/(taskTimeConstant*taskTimeConstant);
    Kp[1] = 3200.0/(taskTimeConstant*taskTimeConstant);
    double Kv[2];
    Kv[0] = 20*ksi[0]/taskTimeConstant;
    Kv[1] = 30*ksi[1]/taskTimeConstant;
    double Ki[2] = {33.5, 10.5};
    double Ka[2] = {0.0, 0.0};
    */

    //Interpolator parameters: Initial x=0.031827      y = -0.007827     z = 0.472972
    //                         Final     0.024000          -0.367062         0.242885 
    double b0_x = 0.031827; //should come from initial joint configuration
    double b1_x = 0.0;
    double b2_x = ((0.031827 - b0_x)*3.0 / (simulationTime * simulationTime)); 
    double b3_x = -((0.031827 - b0_x)*2.0 / (simulationTime * simulationTime * simulationTime));

    double b0_y = -0.007827; //should come from initial joint configuration            
    double b1_y = 0.0;
    double b2_y =  ((-0.367062 - b0_y)*3.0 / (simulationTime * simulationTime)); 
    double b3_y = -((-0.367062 - b0_y)*2.0 / (simulationTime * simulationTime * simulationTime));

    double b0_z = 0.472972; //should come from initial joint configuration
    double b1_z = 0.0;
    double b2_z = ((0.242885 - b0_z)*3.0 / (simulationTime * simulationTime)); 
    double b3_z = -((0.242885 - b0_z)*2.0 / (simulationTime * simulationTime * simulationTime));


    /* 
    unsigned int interPolationDegree = 4;
    double a[numberOfJoints][interPolationDegree];
    for (unsigned int i = 0; i < numberOfJoints; i++)
    {
        a[i][0] = jointInitialPose(i);
        a[i][1] = 0.0;
        a[i][2] = ((jointFinalPose(i) - jointInitialPose(i))*3.0 / (simulationTime * simulationTime));
        a[i][3] = -((jointFinalPose(i) - jointInitialPose(i))*2.0 / (simulationTime * simulationTime * simulationTime));
    }

    //joint feed forward torques
    double feedforwardJointTorque[numberOfJoints];
    for (unsigned int i = 0; i < numberOfJoints; i++)
    {
        feedforwardJointTorque[i] = 0.0;
    }
    */   


    //Main simulation loop
    for (double t = 0.0; t <= simulationTime; t = t + timeDelta)
    {
        
        //Interpolation (Desired) q = a0+a1t+a2t^2+a3t^3
        //Do we feed these values? then         jointPoses[0] = jointPoses[1];         jointRates[0] = jointRates[1];
        // But I don't think so, in control desired trajectory plays role of the reference that the controller should strive for from its actual (previous, current) state.
        
        cartX[1][4].p[0] = b0_x + b1_x * t + b2_x * t * t + b3_x * t * t*t;
        cartX[1][4].p[1] = b0_y + b1_y * t + b2_y * t * t + b3_y * t * t*t;
        cartX[1][4].p[2] = b0_z + b1_z * t + b2_z * t * t + b3_z * t * t*t;
        cartXDot[1][4].vel[0] = b1_x + 2 * b2_x * t + 3 * b3_x * t*t;
        cartXDot[1][4].vel[1] = b1_y + 2 * b2_y * t + 3 * b3_y * t*t;
        cartXDot[1][4].vel[2] = b1_z + 2 * b2_z * t + 3 * b3_z * t*t;
        cartXDotDot[1][4].vel[0] = 2 * b2_x + 6 * b3_x*t;
        cartXDotDot[1][4].vel[1] = 2 * b2_y + 6 * b3_y*t;
        cartXDotDot[1][4].vel[2] = 2 * b2_z + 6 * b3_z*t;
        // printf("%f          %f      %f     %f         %f        %f      %f\n", t, cartX[1][4].p[0], cartX[1][4].p[1], cartX[1][4].p[2], cartXDot[1][4].vel[0], cartXDot[1][4].vel[1], cartXDot[1][4].vel[2]);
        // printf("Desired Cartesian values: %f          %f      %f     %f         %f        %f      %f\n", t, cartX[1][4].p[0], cartX[1][4].p[1], cartX[1][4].p[2], cartXDot[1][4].vel[0], cartXDot[1][4].vel[1], cartXDot[1][4].vel[2]);
      
       /*
        for (unsigned int i = 0; i < numberOfJoints; i++)
        {
            jointPoses[1](i) = a[i][0] + a[i][1] * t + a[i][2] * t * t + a[i][3] * t * t*t;
            jointRates[1](i) = a[i][1] + 2 * a[i][2] * t + 3 * a[i][3] * t*t;
            jointAccelerations[1](i) = 2 * a[i][2] + 6 * a[i][3] * t;
            //printf("Desired joint values: %f   %d       %f          %f      %f\n", t, i, jointPoses[1](i), jointRates[1](i), jointAccelerations[1](i));
            //printf("%f         %f          %f      %f       %f     %f       %f\n", t, jointPoses[1](0), jointPoses[1](1), jointRates[1](0), jointRates[1](1), jointAccelerations[1](0), jointAccelerations[1](1));
        }
        */
    
        status = constraintSolver.CartToJnt(jointPoses[0], jointRates[0], jointAccelerations[0], alpha, betha, externalNetForces, jointTorques[0]);
        constraintSolver.getLinkCartesianPose(cartX[0]);
        constraintSolver.getLinkCartesianVelocity(cartXDot[0]);
        constraintSolver.getLinkCartesianAcceleration(cartXDotDot[0]);
        double alfa(0.0), gamma(0.0), beta(0.0);
        cartX[0][4].M.GetEulerZYX(alfa,gamma,beta);
        // printf("%f          %f      %f     %f         %f        %f      %f\n",  t, cartX[0][4].p[0], cartX[0][4].p[1], cartX[0][4].p[2], alfa, gamma, beta);
        // printf("Actual cartesian values: %f          %f      %f     %f         %f        %f      %f\n", t, cartX[0][4].p[0], cartX[0][4].p[1], cartX[0][4].p[2], cartXDot[0][4].vel[0], cartXDot[0][4].vel[1], cartXDot[0][4].vel[2]);
        // printf("%f          %f      %f     %f         %f        %f      %f\n", t, cartXDot[0][4].vel[0], cartXDot[0][4].vel[1], cartXDot[0][4].vel[2], cartXDot[0][4].rot[0], cartXDot[0][4].rot[1], cartXDot[0][4].rot[2]);
        
        //Error
        // for (unsigned int i = 0; i < numberOfJoints; i++)
        // {
        //     jointPoses[2](i) = jointPoses[1](i) - jointPoses[0](i);
        //     jointRates[2](i) = jointRates[1](i) - jointRates[0](i);
        //     jointAccelerations[2](i) = jointAccelerations[1](i) - jointAccelerations[0](i);
        //     jointPoses[3](i) += timeDelta * jointPoses[2](i);
        //printf("Error joint values: %f       %d     %f      %f          %f\n", t, i, jointPoses[2](i), jointRates[2](i),jointAccelerations[2](i));
        // }

        //Integration(robot joint values for rates and poses; actual) at the given "instanteneous" interval for joint position and velocity.
        for (unsigned int i = 0; i < numberOfJoints; i++)
        {
            jointRates[0](i) = jointRates[0](i) + jointAccelerations[0](i) * timeDelta; //Euler Forward
            jointPoses[0](i) = jointPoses[0](i) + (jointRates[0](i) - jointAccelerations[0](i) * timeDelta / 2.0) * timeDelta; //Trapezoidal rule
        }
        printf("%f       %f     %f      %f     %f    %f     %f     %f      %f     %f    %f\n", t,jointPoses[0](0), jointPoses[0](1),jointPoses[0](2), jointPoses[0](3), jointPoses[0](4), jointRates[0](0), jointRates[0](1), jointRates[0](2), jointRates[0](3), jointRates[0](4));
        // printf("%f\n",jointPoses[0](4));

        cartX[2][4].p[0] = cartX[1][4].p[0] - cartX[0][4].p[0];
        cartX[2][4].p[1] = cartX[1][4].p[1] - cartX[0][4].p[1];
        cartX[2][4].p[2] = cartX[1][4].p[2] - cartX[0][4].p[2];
        cartXDot[2][4].vel[0] = cartXDot[1][4].vel[0] - cartXDot[0][4].vel[0];
        cartXDot[2][4].vel[1] = cartXDot[1][4].vel[1] - cartXDot[0][4].vel[1];
        cartXDot[2][4].vel[2] = cartXDot[1][4].vel[2] - cartXDot[0][4].vel[2];
        cartXDotDot[2][4].vel[0] = cartXDotDot[1][4].vel[0] - cartXDotDot[0][4].vel[0];
        cartXDotDot[2][4].vel[1] = cartXDotDot[1][4].vel[1] - cartXDotDot[0][4].vel[1];
        cartXDotDot[2][4].vel[2] = cartXDotDot[1][4].vel[2] - cartXDotDot[0][4].vel[2];
        cartX[3][4].p[0] += timeDelta * cartX[2][4].p[0]; //for integral term;
        cartX[3][4].p[1] += timeDelta * cartX[2][4].p[1];
        cartX[3][4].p[2] += timeDelta * cartX[2][4].p[2];
        //printf("%f          %f      %f     %f         %f        %f      %f\n", t, cartX[2][4].p[0], cartX[2][4].p[1], cartX[2][4].p[2], cartXDot[2][4].vel[0], cartXDot[2][4].vel[1], cartXDot[2][4].vel[2]);
         

        //Regulator or controller
        
        //acceleration energy control
        betha(0) = alpha(0, 0)*(K*cartXDotDot[2][4].vel[0] + (Kv[0]) * cartXDot[2][4].vel[0] + (Kp[0]) * cartX[2][4].p[0]+ Ki[1] * cartX[3][4].p[0]); // 0.5xgain
        //betha(1) = alpha(1, 1)*((Kp[1]) * cartXDotDot[2][4].vel[1] + (Kv[0]) * cartXDot[2][4].vel[1] + (Kp[1]) * cartX[2][4].p[1] + Ki[1] * cartX[3][4].p[0]);
        
        /*
        //computed joint torque control
        feedforwardJointTorque0 = jointAccelerations[1](0) + (Kp[0])*jointPoses[2](0) + (Kv[0])*jointRates[2](0) + (Ki[0])*jointPoses[3](0);
        feedforwardJointTorque1 = jointAccelerations[1](1) + (Kp[1])*jointPoses[2](1) + (Kv[1])*jointRates[2](1)+ (Ki[1])*jointPoses[3](1);
        jointTorques[0](0) = jointTorques[0](0) + feedforwardJointTorque0;
        jointTorques[0](1) = jointTorques[0](1) + feedforwardJointTorque1;
        */
        //For cartesian space control one needs to calculate from the obtained joint space value, new cartesian space poses.
        //Then based on the difference of the signal (desired-actual) we define a regulation function (controller)
        // this difference should be compensated either by joint torques.
        // externalNetForces[4].force[0] = cartXDotDot[2][4].vel[0] + ((Kv[0]) * cartXDot[2][4].vel[0] + (Kp[0]) * cartX[2][4].p[0] + (Ki[0]) * cartX[3][4].p[0]);
        externalNetForces[4].force[1] = cartXDotDot[2][4].vel[1] + ((Kv[1]) * cartXDot[2][4].vel[1] + (Kp[1]) * cartX[2][4].p[1] + (Ki[1]) * cartX[3][4].p[1]);
        externalNetForces[4].force[2] = cartXDotDot[2][4].vel[2] + ((Kv[2]) * cartXDot[2][4].vel[2] + (Kp[2]) * cartX[2][4].p[2] + (Ki[2]) * cartX[3][4].p[2]);
        /*
        //computed joint torque control
        for (unsigned int i = 0; i < numberOfJoints; i++)
        {
            feedforwardJointTorque[i] = jointAccelerations[1](i) + (Kp[i]) * jointPoses[2](i) + (Kv[i]) * jointRates[2](i) + (Ki[i]) * jointPoses[3](i);
            jointTorques[0](i) = jointTorques[0](i) + feedforwardJointTorque[i];

        }
        */

    }
    //~Definition of process main loop
    //-------------------------------------------------------------------------------------//





    return 0;
}

